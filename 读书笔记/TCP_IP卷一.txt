第一章概述
TCP/IP通常被认为是一个四层协议系统
应用层、运输层、网络层、链路层。运输层有TCP和UDP，网络层有IP、ICMP、IGMP。
应用层有Telnet远程登录，FTP，SMTP，SNMP。
网桥是在链路层上对网络进行互联。路由器是在网络层上进行互联。

封装：
当应用程序用TCP传输，数据送入协议栈中，逐个通过每一层直到被当做一串比特流送入网络，其中每一层对收到的数据
都要增加一些首部信息。

TCP传给IP的数据单元称作TCP报文段或简称为TCP
segment.IP传给网络接口层的数据单元称作IP数据报(IPdatagram)。通过以太网传输的比特流称作帧(Frame)。

分用：当主机收到一个以太网数据帧，数据从协议栈由底层向上升，同时去掉各层协议加上报文首部，每层协议盒
要去检查报文首部中协议标识，确定接收数据的上层协议。

网络层和运输层之间的区别是最为关键的：网络层(IP)提供点到点的服务，而运输层(TCP和UDP)提供端到端的服务。

第二章链路层
链路层最大数据帧长度MTU（最大传输单元）
重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU它被称作路径MTU。

第三章IP网际协议
IP特性：不可靠的意思是它不能保证IP数据报能成功地到达目的地。
无连接这个术语的意思是IP并不维护任何关于后续数据报的状态信息。

TTL生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。
TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。
当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。

IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某
个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据
报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么
(1)如果IP层被设置为路由器的功能，那么就对数据报进行转发
否则(2)数据报被丢弃。

路由表内容：目的IP地址。下一跳路由器IP地址。标志。网络接口。
IP路由选择是逐跳地进行的。首先匹配IP地址(主机地址)，其次匹配网络号，不行寻找默认表目。

第四章ARP：地址解析协议
ARP为IP地址到对应的硬件地址之间提供动态映射。我们之所以用动态这个词是因为这个过程是自动完成的，
一般应用程序用户或系统管理员不必关心。

ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。

第五章RARP：逆地址解析协议
网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是
从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响
应该无盘系统的IP地址（在RARP应答中）。一个RARP请求在网络上进行广播，它在分组中标明发送端的硬
件地址，以请求相应IP地址的响应。应答通常是单播传送的。RARP带来的问题包括使用链路层广播，这样
就阻止大多数路由器转发RARP请求，只返回很少信息：只是系统的IP地址。

第六章ICMP：Internet控制报文协议
ICMP报文是在IP数据报内部被传输的。
ICMP分为差错报文和查询报文

ICMP地址掩码请求与应答：系统广播它的ICMP请求报文
ICMP时间戳请求允许系统向另一个系统查询当前的时间。
ICMP差错报文，即端口不可达报文

第七章Ping程序
目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。

第八章Traceroute程序
Traceroute程序程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。
Traceroute程序程序还可以让我们使用IP源路由选项。
Traceroute程序使用ICMP报文和IP首部中的TTL字段（生存周期）。

工作过程：
开始时发送一个TTL字段为1的UDP数据报，然后将TTL字段每次加1，以确定路径中的每个路由器。
每个路由器在丢弃UDP数据报时都返回一个ICMP超时报文2而最终目的主机则产生一个ICMP端口不可达的报文。

第九章IP选路
netstat-rn查看路由表
当分组被发往间接路由时，IP地址指明的是最终目的地，但是链路层地址指明的是网关(即下一站路由器)。
G标志区分了直接路由和间接路由。H标志表明，目的地址(netstat命令输出第一行)是一个完整的主机地址。
ICMP重定向差错：当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差
错报文给IP数据报的发送端。
路由守护程序（RoutingDaemon）是在路由器上运行路由选择协议的程序，与它的邻居路由器进行对话，通常
被叫做路由守护程序。这个路由守护程序在接收到来自邻居路由器的信息时更新kernel路由表。

第十章动态选路协议
动态选路协议，用于路由器间的通信，RIP，选路信息协议。
RIP报文包含在UDP数据报中。

第十一章UDP：用户数据报协议
UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。
UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的
UDP数据报OK）。这个UDP长度是有冗余的。
IP首部的检验和，它只覆盖IP的首部。
UDP和TCP在首部中都有覆盖它们首部和数据的检验和。

IP分片：
IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，
也可以发生在中间路由器上。
当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立。

ICMP不可达差错。
利用Traceroute可以确定路径的MTU

ICMP源站抑制差错
我们同样也可以使用UDP产生ICMP“源站抑制(sourcequench)”差错。当一个系统（路由器或主机）
接收数据报的速度比其处理速度快时，可能产生这个差错。

UDP数据报。IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。
大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符的特点。
当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，
就向每个端点传送一份数据报的复制（端点的本地IP地址可以含有星号，它可匹配任何目的IP地址）

第十二章广播和多播
广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。
IP多播提供两类服务：
1)向多个目的地址传送数据。
2)客户对服务器的请求。

第十三章IGMP：Internet组管理协议
IGMP：它让一个物理网络上的所有系统知道主机当前所在的多播组。
IGMP也被当作IP层的一部分。IGMP报文通过IP数据报进行传输。
多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况
1)当第一个进程加入一个组时，主机就发送一个IGMP报告。
2)进程离开一个组时，主机不发送IGMP报告。
3)多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。
4)主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告

第十四章DNS：域名系统
域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换
及有关电子邮件的选路信息。
DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两
个库函数gethostbyname(3)和gethostbyaddr(3)。
每个名字服务器必须知道如何同根的名字服务器联系。
根服务器则知道所有二级域中的每个授权名字服务器的名字和位置（即IP地址）。
DNS的一个基本特性是使用超高速缓存。
DNS查询报文最常用的是A类，即期望获得IP地址。
为了减少Internet上DNS的通信量，所有的名字服务器均使用高速缓存。在标准的Unix实现中，
高速缓存是由名字服务器而不是由名字解析器维护的。
DNS查询和响应通常经过广域网。

第十五章TFTP：简单文件传送协议
TFTP将使用UDP，是一个简单的协议，适合于只读存储器，仅用于无盘系统进行系统引导。它只使用几种
报文格式，是一种停止等待协议。

第十六章BOOTP：引导程序协议
BOOTP用于无盘系统进行系统引导的替代方法，称为引导程序协议。
BOOTP使用UDP，且通常需与TFTP。BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，
而不是特殊的数据链路层帧。

第十七章TCP：传输控制协议
尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、
可靠的字节流服务。
TCP通过下列方式来提供可靠性：
1、应用数据被分割成TCP认为最适合发送的数据块。
2、当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。
3、当TCP收到发自TCP连接另一端的数据，它将发送一个确认。
4、TCP将保持它首部和数据的检验和。
5、既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。
6、既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
7、TCP还能提供流量控制。

四元组：IP地址、客户端口号、服务器IP地址和服务器端口号
检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。
接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有
任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

第十八章TCP连接的建立与终止
TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。

三次握手：
1、客户端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号ISN。(报文段1)
2、服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的
ISN加1以对客户的SYN报文段进行确认。
3、客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。

ISN随时间而变化，因此每个连接都将具有不同的ISN。这样选择序号的目的在于防止在网络中被延迟的分组
在以后又被传送，而导致某个连接的一方对它作错误的解释。

断开连接：
既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。这原
则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须
通知应用层另一端已经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。

当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，
导致它的TCP端发送一个FIN(报文段6)，客户必须发回一个确认，并将确认序号设置为收到序号加1(报文段7)。

最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各
自的MSS。我们已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部。

TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（MaximumSegment
Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP
数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

平静时间的概念
TCP在重启动后的MSL秒内不能建立任何连接。这就称为平静时间(quiettime)。

FIN_WAIT_2状态
在FIN_WAIT_2状态我们已经发出了FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则
将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN来关闭另一方向的连
接。只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。

对于UDP，我们在6.5节看到这种情况，当一个数据报到达目的端口时，该端口没在使用，它将产生一个
ICMP端口不可达的信息。而TCP则使用复位。

异常释放
TCP发送一个RST而不是通常的FIN。RST报文段中包含一个序号和确认序号。需要注意的是RST报文段不会
导致另一端产生任何响应，另一端根本不进行确认。

呼入连接请求队列
1、正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受
（即三次握手已经完成），但还没有被应用层所接受。
2、应用层将指明该队列的最大长度，这个值通常称为积压值(backlog)。
3、当一个连接请求（即SYN）到达时，TCP使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。
4、如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立。
5、如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段。

第十九章TCP的交互数据流
通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起
发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms
的时延等待是否有数据一起发送。

Nagle算法
该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送
其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越
之处在于它是自适应的：确认到达得越快，数据也就发送得越快。

socket用户可以使用TCP_NODELAY选项来关闭Nagle算法。

交互数据总是以小于最大报文段长度的分组发送。在Rlogin中通常只有一个字节从客户发
送到服务器。Telnet允许一次发送一行输入数据，但是目前大多数实现仍然发送一个字节。

第二十章TCP的成块数据流

通常使用隔一个报文段确认的策略。
一个ACK可以确认两个收到的报文，使用TCP的滑动窗口协议时，接收方不必确认每一个收到的分组。

利用ACK进行窗口更新。

滑动窗口：
1、发送方不必发送窗口大小数据。
2、ACK将窗口右移。
3、窗口右边沿不能左移。
4、接收方发送ACK不用等窗口填满。

PUSH标志，发送方用该标志通知接收方将所收到的数据全部提交给接收进程。

慢启动为发送方TCP增加一个窗口，拥塞窗口cwnd。
拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段
（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值
作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。

发送分组时间取决于：传播时延和媒体速率。

带宽时延乘积：
capacity(bit)=bandwidth(b/s)*round-triptime(s)

紧急方式:
紧急指针是指向紧急数据的最后一个字节.

第二十一章TCP的超时和重传
对于每个链接，TCP管理4个不同定时器：
1、重传定时器使用于当希望收到另一端的确认。
2、坚持定时器使窗口大小信息保持不断流动。
3、保活定时器可检测到一个空闲链接。
4、2MSL定时器测量一个链接处于TIME_WAIT状态时间。

超时重传，指数退避(exponentialbackoff)。

重传超时时间RTO（RetransmissionTimeOut）
Karn算法当一个超时和重传发生时，在重传数据的确认最后到达之前，不能更新RTT估计器，因为我们并不
知道ACK对应哪次传输（也许第一次传输被延迟而并没有被丢弃，也有可能第一次传输的ACK被延迟）

TCP实现在任何时候对每个连接仅测量一次RTT值。在发送一个报文段时，如果给定连接的定时器已经被使用，
则该报文段不被计时。


拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口cwnd和一个慢启动门限ssthresh。
1、初始化链接中cwnd为1个报文段，ssthresh为65535个字节。
2、拥塞避免是发送方使用的流量控制，通告窗口是接收方进行的流量控制。
3、如果发生拥塞ssthresh被设置为当前窗口大小的一半。超时拥塞，cwnd设置为1。
4、新的数据被确认时，增加cwnd，若cwnd小于ssthresh，则进行慢启动，否则进行拥塞避免。

拥塞避免算法要求每次收到一个确认时将cwnd增加1/cwnd。与慢启动的指数增加比起来，这是一种加性增长。

快速重传：
源于伯克利的TCP实现对收到的重复ACK进行计数，当收到第3个时，就假定一个报文段已经丢失并重传自那个
序号起的一个报文段。这就是Jacobson的快速重传算法，该算法通常与他的快速恢复算法一起配合使用。
快速恢复：
1、当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为
ssthresh加上3倍的报文段大小。
2、每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。
3、当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后
的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所
有中间报文段的确认。

TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。
1、一个接收到的源站抑制引起拥塞窗口cwnd被置为1个报文段大小来发起慢启动。ssthresh没有变化。
2、一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。

TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。

第二十二章TCP的坚持定时器

发送方使用一个坚持定时器(persisttimer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发
出的报文段称为窗口探查。
坚持状态与重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个
过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。

糊涂窗口综合症SWS(SillyWindowSyndrome）
该现象可发生在两端中的任何一端：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），
而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。
避免措施：
接收方：
1、不通告小窗口。能够接收一个最大报文，或者缓冲区的一半，再来发送窗口通告。
发送方只有以下条件之一满足时才发送数据：
1、可以发送一个满长度的报文段；
2、可以发送至少是接收方通告窗口大小一半的报文段；
3、可以发送任何数据并且不希望接收ACK（即没有还未被确认的数据）或者该连接上不能使用Nagle算法。

Nagle算法，它正是用于解决这个问题的。

第二十三章TCP的保活定时器
保活功能就是试图在服务器端检测到这种半开放的连接。
对保活功能是有争议的。协议专家继续在争论该功能是否应该归入运输层，或者应当完全由应用层来处理。
在连接空闲两个小时后，在一个连接上发送一个探查分组来完成保活功能。可能会发生4种不同的情况：
对端仍然运行正常、对端已经崩溃、对端已经崩溃并重新启动以及对端当前无法到达。

第二十四章TCP的未来和性能
1、TCP的路径MTU发现按如下方式进行：在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的
报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。
2、长肥管道，具有大的带宽时延乘积的网络被称为长肥网络，而一个运行在LFN上的TCP连接被称为长肥管道。

窗口扩大选项使TCP的窗口定义从16bit增加为32bit。这并不是通过修改TCP首部来实现的，TCP首部仍然使用16bit，
而是通过定义一个选项实现对16bit的扩大操作(scalingoperation)来完成的。于是TCP在内部将实际的窗口大小
维持为32bit的值。

时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个
收到的ACK计算RTT（我们必须说“每一个收到的ACK”而不是“每一个报文段”，是因为TCP通常用一个ACK来确认多个
报文段）。我们提到过目前许多实现为每一个窗口只计算一个RTT，对于包含8个报文段的窗口而言这是正确的。然
而，较大的窗口大小则需要进行更好的RTT计算。


