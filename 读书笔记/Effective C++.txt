导读：

被声明为explicit的构造函数通常比其non-explicit更受欢迎，因为他们禁止编译器执行非预期的类型转换。
构造调用operator= 是调用的copy构造函数。只有当新对象被定义时，调用构造函数，没有新对象则调用赋值函数。

值传递用户自定义类型通常是坏主意，pass-by-reference-to-const往往是比较好的选择。

第一章 让自己习惯C++
尽量用const，enum，inline替换#define，也可以认为用编译器替换预处理器。
enum不能取地址。
对于单纯常量，最好以const对象或者enums替换#defines。
对于形似函数的宏，最好用inline替换#define。
const写在类型之前 或者  类型之后星号之前，两种写法相同。

const成员函数：
1、他们使得class接口比较容易被理解。得知按个函数可以改动对象，哪个函数不能改动对象。
2、他们使操作const对象变得可能。

两个成员函数如果只是常量性不同，可以被重载。
mutable可以释放掉non-static成员变量的bitwise constness约束。
常量性转除。
const_cast<char&>(static_cast<const TextBlock&>(*this)[position])
将op[]返回值的const去除。给this的对象加上const限制。
const的作用：
1、在指针和迭代器上；
2、在指针、迭代器和reference指的对象上。
3、在函数的参数和返回类型上。
4、在local变量身上。
5、在成员函数身上。

当const和non-const成员函数有着等价地实现时，令non-const版本调用const版本可避免代码重复。

C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。所以构造函数的最佳写法：使用
成员初始化列表进行初始化。
class成员变量总是以其声明次序被初始化。

C++保证，函数内的local static对象会在 该函数调用期间或者首次遇上该对象之定义式时被初始化。
不同的编译单元内的non-local static对象的初始化相对于次序并无明确定义。

注意：
1、为内置对象进行手工初始化，因为C++并不保证初始化。
2、构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。
3、为免除“跨编译单元之初始化次序”，以local static对象替换non-local static对象。

第二章：构造，析构和赋值运算
如果打算在一个“内涵regerence成员”的class内支持赋值操作，你必须定义copy assignment操作符。面对
“内涵const成员”的class ，编译器反应也是一样。

将copy构造函数和copy assignment操作符声明为private，阻止调入。但是这种方法并不是绝对安全的，因为
member和friend还是可以调用他们的。所以只有声明就好。不去定义就会在连接期获得错误。

继承一个uncopayable可以将连接期错误转移到编译期。所以最好继承例如boost::noncopayable。可以保证
正常工作。

多态性质的base classes应该声明一个virtual析构函数，如果class带有任何虚函数，他就应该拥有一个虚析构。
classes如果不是基类或者需要多态性，就不应该声明析构函数。

如果析构函数可能会出现异常，最好将可能发生异常的功能，重新开辟一个函数，供用户调用。在析构时，判断是否
需要调用该函数。如果不需要调用该函数，则可以直接析构。总之就是希望用户可以第一时间调用并处理该函数。否则
如果异常发生，只能强迫结束程序或者吞下异常。






