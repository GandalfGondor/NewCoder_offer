Redis C语言实现

没有直接使用C风格字符串表示。使用SDS抽象类型。并将SDS用作Redis默认字符串表示。
键值对： set msg “this is redis”
1、键是字符串对象，底层是一个保存字符串"msg"的 SDS。
2、值是字符串对象，对象时保存值"this is redis"的SDS。

rpush list "A","B","C"
1、键值是字符串对象，保存字符串“list” 的SDS。
2、值是列表对象，列表有三个字符串对象，分别是 "A","B","C" 三个SDS。

二进制安全：
C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符。限制了不能保存
图片，音频，视频，压缩文件的二进制数据。
SDS中的buf来保存，len表示长度，free表示还有剩余多少位置。

SDS优点：
1、常数复杂度获取字符串。
2、杜绝缓冲区溢出。
3、减少修改字符串长度所需内存重新分配次数。
4、二进制安全。
5、兼容部分C字符串函数。

第三章 链表
Redis使用C语言构建自己的链表。
Redsi服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。

ListNode{
	struct ListNode *prev;
	struct ListNode *next;
	void *value;
}
list{
	ListNode *head;
	ListNode *tail;
	unsigned long len;
	void *(*dup)(void *ptr);
	void (*free)(void *ptr);
	int (*match)(void *ptr,void *key);
}
特点：
1、双端指针。
2、两头是NULL，无环。
3、有表头指针和表尾指针。
4、有链表长度计数器。
5、多态。

Redis中链表被用于列表键值，发布与订阅、慢查询、监视器。

第四章 字典
1、字典，又称为符号表、关联数组、或者映射，是一种用于保存键值对的抽象数据结构。
Redis数据库的增删改查都是构建在对字典的操作之上。
Redis字典使用哈希表作为底层实现。哈希表里面有多个节点，每个哈希表节点对就保存了字典中的一个键值对。
哈希表节点：
struct dictEntry{
void *key;
union{
	void *val;
	unint64_tu64;
	int64_ts64;
}v;
struct dictEntry *next;
};
next的属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接在一起，以此来解决冲突
问题。
哈希表:
struct dichtht{
	dictEntry **table;
	unsigned long size;
	unsigned long sizemask;  //等于size-1;
	unsigned long used;
}dictht;
table存储着键值对。size属性记录了哈希表的大小。

struct dict{
	dictType *type;
	void *privdata;
	dictht ht[2]; //每个字典有两个哈希表，一个平时使用，一个仅在rehash时使用。
	int rehashidx;
}
Redis的哈希表使用链地址法来解决键值冲突。即next指针。
同时为了速度考虑，使用头插法。
考虑到rehash时，ht中保存的键值对有上亿个，所以需要多次分段进行rehash。
所以需要rehashidx来记录时候完成rehash。


第五章  跳跃表
跳跃表支持平均O(logN),O(N)复杂度的节点查找。
Redis使用跳跃表作为有序集合键的底层实现之一。
有序集合所有数据保存在跳跃表里面。
Redis跳跃表是由zskiplist，zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，比如表头节点，
表尾节点，长度。zskiplistNode则是用于表示跳跃表节点。
每个跳跃表节点的层高都是1至32之间的随机数。
struct zskiplistNode{
	struct zskiplistLevel{
		struct zskiplistNode *forward;
		unsigned int span;		//跨度
	}level[];
	struct zskiplistNode* backward;		
	double score;	//跳跃表中所有节点都按照分值从小到大来排序。
	robj *obj;		//指向一个字符串，字符串对象保存着SDS值。分值一样时候，按照SDS字典序排序。
}zskiplistNode;

struct zskiplist{
	struct zskiplistNode *header,*tail;		//表头节点和表尾节点
	unsigned long length;	//表中节点的数量
	int level;   //表中最大的节点层数
}

第六章 整数集合
整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，且这个集合的元素数量不多的时候，Redis就会
使用整数集合作为集合键的底层实现。
struct intset{
	uint32_t encoding;
	uint32_t length;	//
	int8_t contents[];   //每个元素都是一个数组项，从小到大排列，不重复。具体类型是encoding类型
}

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有类型都要长时，整数集合需要
先进行升级，然后才能将新元素添加到整数集合里面。
升级首先要做的是，根据新类型的长度，以及集合元素的数量，对底层数组进行空间重新分配。

第七章
压缩列表
压缩列表是列表键和哈希键的底层实现之一。
带给您一个链表只包含少量列表项，每个列表项是小整数或者短字符串，Redis使用压缩列表来做底层实现。
哈希键同理。

第八章	对象
对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象，列表对象，哈希对象，集合
对象或者有序集合对象的其中一种。
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，便会创建两个对象，
一个对象用作键值对的键，另一个对象用作键值对的值。
struct redisObject{
	unsigned type:4;
	unsigned encoding:4;
	void *ptr;
}

字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的。
列表对象的编码可以是ziplist或者linkedlist。
哈希对象的编码可以是ziplist或者hashtable。
集合对象的编码可以是intset或者hashtable
有序集合的编码可以是ziplist或者skiplist。

sadd numbers 1，2，3
若是用hashtable集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个
集合元素，而字典的值则全部被设置为NULL。

Redis内存回收，利用引用计数实现内存的回收机制。

对象共享。键A和键B可能共享一个对象。但是仅共享0到9999的字符串对象，因为如果越复杂的字符串需要共享，
匹配所用的CPU消耗约大。


空转时长，记录对象最后一次被访问的时间。当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转
时长较高的那部分键会优先被服务器释放。


第九章 数据库
默认情况下，Redis客户端目标数据库0号数据库，但是客户端可以通过执行SELECT命令来切换目标数据库。

Redis是一个键值对数据库服务器，服务器中的每一个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构
的dict字典保存了数据库中的所有键值对。称这个字典为键空间。
数据库主要由两个字典构成，dict字典保存键值对，expires字典负责保存键的过期时间。


键空间和用户所见的数据库是直接对应的。因为数据库的键空间是一个字典，所以针对数据库的操作，比如添加一个
键值到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间
字典进行操作来实现的。

EXPIRE命令使得，客户端可以以毫秒为精度为数据库中的某个键设置生存时间。

过期键删除策略：
1、定时删除。//CPU不友好，内存友好
2、惰性删除。//CPU友好，内存不友好
3、定期删除。//折中
Redis使用惰性和定期删除两种策略。

AOF，RDB和复制功能对过期键的处理。
RDB：执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已经过期的键不会被保存
到新创建的RDB文件中。
AOF：当服务器以AOF持久化模式运行的时候，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除
不会有影响，若是过期，则会向AOF文件追加一个DEL命令。重写的时候不会重写已经过期的键。


第十章 RDB持久化
Redis是内存数据库，他将自己的数据库状态存储在内存里面，所以如果不想办法将储存在内存中的数据库状态保存
到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失。
所以Redis提供了RDB持久化功能。可以将Redis在内存中的数据库状态保存到磁盘里面。

SAVE和BGSAVE都可以生成RDB文件，SAVE命令会阻塞服务器进程，直到RDB文件创建完毕。
BGSAVE命令会派生出一个子进程，然后子进程负责创建RDB文件。

AOF文件的更新频率通常比RDB文件的更新频率高。
1、如果服务器开启了AOF持久化功能，那么服务器就会优先使用AOF文件来还原数据库。
2、AOF功能处于关闭状态时，服务器使用RDB文件来还原数据库状态。

RDB文件载入时的服务器状态，一直阻塞，直到载入工作完成。

服务器保存一个
struct  redisServer
{
	struct saveparam *saveparams；
	。。。
}
struct saveparam
{
	time_t seconds;
	int changes;
}
还维持一个计数器，记录修改次数。还有一个时间戳，记录上次执行bgsave时间。
Redis周期性的检查服务器检测save选项保存的条件是否满足。


RDB文件：
“REDIS”+db_version+databases+EOF+check_sum

database部分结构：
selectdb+db_number+key_value_pairs;

RDB文件是一个经过压缩的二进制文件，由多个部分组成。
服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE
命令。


第十一章	AOF持久化
与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令
来记录数据库状态。
AOF持久化功能的实现可以分为：
1、命令追加
2、文件写入
3、文件同步

服务器配置appendfsync值决定行为如下：
1、将aof_buf缓冲区中的所有内容写入并同步到AOF文件。
2、将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步距离1s以上，则再次同步，专门由一个线程进行服务。
3、将aof_buf缓冲区所有内容写入AOF文件，但是不同步AOF文件。

文件的写入和同步：为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的
时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面。等到缓冲区填满，或者超时之后，才真正的将缓
冲区中的数据写入到磁盘里面。


AOF文件的载入与数据还原
Redis读取AOF文件并还原数据库状态的详细步骤如下。
1、创建一个不带网络连接的伪客户端。
2、从AOF文件中分析并读取一条写命令。
3、使用伪客户端执行被独处的命令。

AOF文件的体积必须加以控制。否则会对Redis服务器，整个宿主计算机造成影响。
为了解决该问题，Redis提供了AOF文件重写功能。
原理：AOF重写不会去读取，分析，写入原来的AOF文件。
所有类型的键都可以用同样的方法取减少AOF文件中的命令数量。首先从数据库中读取键现在的值，然后用一条命令
去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能实现原理。

AOF重写程序放到子进程里面执行，这样做可以同时达到两个目的：
1、子进程AOF重写期间，父进程（服务器）可以继续处理客户端的请求。
2、子进程带有父进程数据，避免锁的使用，保证数据的安全性。

执行BGREWEITEAOF。

子进程进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，
从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。
所以服务进程需要提供以下几个操作：
1、执行客户端发来的命令。
2、将执行后的写命令追加到AOF缓冲区。
3、将执行后的写命令追加到AOF重写缓冲区。
可以保证：缓冲区的内容会被写入和同步到AOF文件。服务器执行的所有写命令都会被记录到AOF重写缓冲区。

当子进程完成AOF重写工作之后，他会向父进程发送一个信号，父进程在接受到该信号之后，会调用一个信号处理
函数，并执行一下工作：
1、将AOF重写缓冲区的所有内容写入到新的AOF文件，这是新的AOF文件所保存的状态和当前服务器状态一致。
2、对新的AOF文件进行改名，原子性的覆盖现有AOF文件，完成新旧两个AOF文件的替换。
所以可以看出只有在信号处理函数执行时会对服务器进程造成阻塞，其他时候都不会阻塞。



第十二章  事件
Redis服务器是一个事件驱动程序，需要处理两种事件：
1、文件事件。Redis服务器通过套接字与客户端进行连接。
2、时间事件。Redis服务器中的一些操作需要在给定时间点执行。


