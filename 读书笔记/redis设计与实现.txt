Redis C语言实现

没有直接使用C风格字符串表示。使用SDS抽象类型。并将SDS用作Redis默认字符串表示。
键值对： set msg “this is redis”
1、键是字符串对象，底层是一个保存字符串"msg"的 SDS。
2、值是字符串对象，对象时保存值"this is redis"的SDS。

rpush list "A","B","C"
1、键值是字符串对象，保存字符串“list” 的SDS。
2、值是列表对象，列表有三个字符串对象，分别是 "A","B","C" 三个SDS。

二进制安全：
它并不像C语言那样，使用’\0’作为判定一个字符串的结尾，所以如果你保存的字符串内存在’\0’，c语言自
会识别前面的数据，后面的就会被忽略掉，所以说是不安全的。而redis是使用了独立的len，这样可以保证
即使存储的数据中有’\0’这样的字符，它也是可以支持读取的。而且前面介绍到Redis的string可以支持各
种类型（图片、视频、静态文件、css文件等）。

SDS优点：(空间预分配，惰性空间释放)
1、常数复杂度获取字符串。
2、杜绝缓冲区溢出。
3、减少修改字符串长度所需内存重新分配次数。
4、二进制安全。
5、兼容部分C字符串函数。

第三章 链表
Redis使用C语言构建自己的链表。
Redsi服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。

ListNode{
	struct ListNode *prev;
	struct ListNode *next;
	void *value;
}
list{
	ListNode *head;
	ListNode *tail;
	unsigned long len;
	void *(*dup)(void *ptr);
	void (*free)(void *ptr);
	int (*match)(void *ptr,void *key);
}
特点：
1、双端指针。
2、两头是NULL，无环。
3、有表头指针和表尾指针。
4、有链表长度计数器。
5、多态。

Redis中链表被用于列表键值，发布与订阅、慢查询、监视器。

第四章 字典
1、字典，又称为符号表、关联数组、或者映射，是一种用于保存键值对的抽象数据结构。
Redis数据库的增删改查都是构建在对字典的操作之上。
Redis字典使用哈希表作为底层实现。哈希表里面有多个节点，每个哈希表节点对就保存了字典中的一个键值对。
哈希表节点：
struct dictEntry{
void *key;
union{
	void *val;
	unint64_tu64;
	int64_ts64;
}v;
struct dictEntry *next;
};
next的属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接在一起，以此来解决冲突
问题。
哈希表:
struct dichtht{
	dictEntry **table;
	unsigned long size;
	unsigned long sizemask;  //等于size-1;
	unsigned long used;
}dictht;
table存储着键值对。size属性记录了哈希表的大小。

struct dict{
	dictType *type;
	void *privdata;
	dictht ht[2]; //每个字典有两个哈希表，一个平时使用，一个仅在rehash时使用。
	int rehashidx;
}
Redis的哈希表使用链地址法来解决键值冲突。即next指针。
同时为了速度考虑，使用头插法。
考虑到rehash时，ht中保存的键值对有上亿个，所以需要多次分段进行rehash。
所以需要rehashidx来记录时候完成rehash。


第五章  跳跃表
跳跃表支持平均O(logN),O(N)复杂度的节点查找。
Redis使用跳跃表作为有序集合键的底层实现之一。
有序集合所有数据保存在跳跃表里面。
Redis跳跃表是由zskiplist，zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，比如表头节点，
表尾节点，长度。zskiplistNode则是用于表示跳跃表节点。
每个跳跃表节点的层高都是1至32之间的随机数。
struct zskiplistNode{
	struct zskiplistLevel{
		struct zskiplistNode *forward;
		unsigned int span;		//跨度
	}level[];
	struct zskiplistNode* backward;		
	double score;	//跳跃表中所有节点都按照分值从小到大来排序。
	robj *obj;		//指向一个字符串，字符串对象保存着SDS值。分值一样时候，按照SDS字典序排序。
}zskiplistNode;

struct zskiplist{
	struct zskiplistNode *header,*tail;		//表头节点和表尾节点
	unsigned long length;	//表中节点的数量
	int level;   //表中最大的节点层数
}

第六章 整数集合
整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，且这个集合的元素数量不多的时候，Redis就会
使用整数集合作为集合键的底层实现。
struct intset{
	uint32_t encoding;
	uint32_t length;	//
	int8_t contents[];   //每个元素都是一个数组项，从小到大排列，不重复。具体类型是encoding类型
}

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有类型都要长时，整数集合需要
先进行升级，然后才能将新元素添加到整数集合里面。
升级首先要做的是，根据新类型的长度，以及集合元素的数量，对底层数组进行空间重新分配。

第七章
压缩列表
压缩列表是列表键和哈希键的底层实现之一。
带给您一个链表只包含少量列表项，每个列表项是小整数或者短字符串，Redis使用压缩列表来做底层实现。
哈希键同理。

第八章	对象
对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象，列表对象，哈希对象，集合
对象或者有序集合对象的其中一种。
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，便会创建两个对象，
一个对象用作键值对的键，另一个对象用作键值对的值。
struct redisObject{
	unsigned type:4;
	unsigned encoding:4;
	void *ptr;
}

字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的。
列表对象的编码可以是ziplist或者linkedlist。
哈希对象的编码可以是ziplist或者hashtable。
集合对象的编码可以是intset或者hashtable
有序集合的编码可以是ziplist或者skiplist。

sadd numbers 1，2，3
若是用hashtable集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个
集合元素，而字典的值则全部被设置为NULL。

Redis内存回收，利用引用计数实现内存的回收机制。

对象共享。键A和键B可能共享一个对象。但是仅共享0到9999的字符串对象，因为如果越复杂的字符串需要共享，
匹配所用的CPU消耗约大。


空转时长，记录对象最后一次被访问的时间。当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转
时长较高的那部分键会优先被服务器释放。


第九章 数据库
默认情况下，Redis客户端目标数据库0号数据库，但是客户端可以通过执行SELECT命令来切换目标数据库。

Redis是一个键值对数据库服务器，服务器中的每一个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构
的dict字典保存了数据库中的所有键值对。称这个字典为键空间。
数据库主要由两个字典构成，dict字典保存键值对，expires字典负责保存键的过期时间。

键空间和用户所见的数据库是直接对应的。因为数据库的键空间是一个字典，所以针对数据库的操作，比如添加一个
键值到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间
字典进行操作来实现的。

EXPIRE命令使得，客户端可以以毫秒为精度为数据库中的某个键设置生存时间。

过期键删除策略：
1、定时删除。//CPU不友好，内存友好
2、惰性删除。//CPU友好，内存不友好
3、定期删除。//折中
Redis使用惰性和定期删除两种策略。

AOF，RDB和复制功能对过期键的处理。
RDB：执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已经过期的键不会被
保存到新创建的RDB文件中。
AOF：当服务器以AOF持久化模式运行的时候，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除
不会有影响，若是过期，则会向AOF文件追加一个DEL命令。重写的时候不会重写已经过期的键。

数据库通知：可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。
有键空间通知，键事件通知。


第十章 RDB持久化
Redis是内存数据库，他将自己的数据库状态存储在内存里面，所以如果不想办法将储存在内存中的数据库状态保存
到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失。
所以Redis提供了RDB持久化功能。可以将Redis在内存中的数据库状态保存到磁盘里面。

SAVE和BGSAVE都可以生成RDB文件，SAVE命令会阻塞服务器进程，直到RDB文件创建完毕。
BGSAVE命令会派生出一个子进程，然后子进程负责创建RDB文件。

AOF文件的更新频率通常比RDB文件的更新频率高。
1、如果服务器开启了AOF持久化功能，那么服务器就会优先使用AOF文件来还原数据库。
2、AOF功能处于关闭状态时，服务器使用RDB文件来还原数据库状态。

BGSAVE命令执行期间，后续的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。
最后，如果BGREWRITEAOF和BGSAVE两个命令不能同时执行：
1、如果BGSAVE正在执行，BGREWRITEAOF会被延迟到BGSAVE命令执行完毕之后执行。
2、如果BGREWRITEAOF命令正在执行，那么BGSAVE命令会被服务器拒绝。
一上来两个情况主要是为了解决性能方面的问题，两个并发子进程同时进行大量的写入操作，可想而知。

RDB文件载入时的服务器状态，一直阻塞，直到载入工作完成。

自动间隔性保存：
save 900 1	服务器900秒之内，修改一次，进行BGSAVE
save 300 10 服务器300秒之内，修改10次，进行BGSAVE
服务器保存一个
struct  redisServer
{
	struct saveparam *saveparams；
	。。。
}
struct saveparam
{
	time_t seconds;
	int changes;
}
还维持一个计数器，记录修改次数。还有一个时间戳，记录上次执行bgsave时间。
Redis周期性的检查服务器检测save选项保存的条件是否满足。serverCron默认每隔100毫秒就会执行一次，该函数
用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置保存条件是否满足。


RDB文件：
“REDIS”+db_version+databases+EOF+check_sum

database部分结构：
selectdb+db_number+key_value_pairs;

RDB文件是一个经过压缩的二进制文件，由多个部分组成。
服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE
命令。


第十一章	AOF持久化
与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令
来记录数据库状态。
AOF持久化功能的实现可以分为：
1、命令追加
2、文件写入
3、文件同步

服务器配置appendfsync值决定行为如下：
1、将aof_buf缓冲区中的所有内容写入并同步到AOF文件。
2、将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步距离1s以上，则再次同步，专门由一个线程进行服务。
3、将aof_buf缓冲区所有内容写入AOF文件，但是不同步AOF文件。

文件的写入和同步：为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的
时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面。等到缓冲区填满，或者超时之后，才真正的将缓
冲区中的数据写入到磁盘里面。


AOF文件的载入与数据还原
Redis读取AOF文件并还原数据库状态的详细步骤如下。
1、创建一个不带网络连接的伪客户端。
2、从AOF文件中分析并读取一条写命令。
3、使用伪客户端执行被独处的命令。

AOF文件的体积必须加以控制。否则会对Redis服务器，整个宿主计算机造成影响。
为了解决该问题，Redis提供了AOF文件重写功能。
原理：AOF重写不会去读取，分析，写入原来的AOF文件。
所有类型的键都可以用同样的方法取减少AOF文件中的命令数量。首先从数据库中读取键现在的值，然后用一条命令
去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能实现原理。

AOF重写程序放到子进程里面执行，这样做可以同时达到两个目的：
1、子进程AOF重写期间，父进程（服务器）可以继续处理客户端的请求。
2、子进程带有父进程数据，避免锁的使用，保证数据的安全性。

执行BGREWEITEAOF。

子进程进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，
从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。
所以服务进程需要提供以下几个操作：
1、执行客户端发来的命令。
2、将执行后的写命令追加到AOF缓冲区。
3、将执行后的写命令追加到AOF重写缓冲区。
可以保证：缓冲区的内容会被写入和同步到AOF文件。服务器执行的所有写命令都会被记录到AOF重写缓冲区。

当子进程完成AOF重写工作之后，他会向父进程发送一个信号，父进程在接受到该信号之后，会调用一个信号处理
函数，并执行一下工作：
1、将AOF重写缓冲区的所有内容写入到新的AOF文件，这是新的AOF文件所保存的状态和当前服务器状态一致。
2、对新的AOF文件进行改名，原子性的覆盖现有AOF文件，完成新旧两个AOF文件的替换。
所以可以看出只有在信号处理函数执行时会对服务器进程造成阻塞，其他时候都不会阻塞。



第十二章  事件
Redis服务器是一个事件驱动程序，需要处理两种事件：
1、文件事件。Redis服务器通过套接字与客户端进行连接。
2、时间事件。Redis服务器中的一些操作需要在给定时间点执行。

文件事件是基于Reactor模式实现的网络通信程序。
文件事件是对套接字操作的抽象：应答，可读，可写。
服务器对文件和时间事件的处理都是同步，有序，原子的执行，服务器不会中途中断处理事件，也不会对事件进行
抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，他们都尽可能少的阻塞时间，并在有需要的时候
主动让出执行权，从而降低事件饥饿的可能性。
例如：会将长时间的写操作分段执行；将耗时很长的持久化操作放到子进程或者线程中执行。
时间事件的实际处理事件通常会比设定的到达时间晚一些。


第十三章	客户端
Redis是典型的一对多服务器程序。
Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对
客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表完成。

伪客户端：处理命令请求来源于AOF文件，而不是网络，所以这种客户端不需要套接字链接，也不需要fd。
	用于：AOF文件还原数据库，而另一个则执行LUA脚本。
普通客户端：使用套接字与服务器通信。

通常情况，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果没有修改，
这个命令不会被写入到AOF文件，也不会被复制到从服务器。

客户端authenticated属性记录客户端是否通过了身份验证。

客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可以用，其中固定大小缓冲区的最大大小为16KB，而可变大小
缓冲区的最大大小不能超过服务器设置的硬性限制。

输出缓冲区限制有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，
客户端在一定时间内，值超过软性限制，也会被关闭。


第十四章	服务器
Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的
数据，通过资源管理来维持服务器自身的运转。

Redis服务器的命令请求，转换成协议格式，然后通过链接到服务器的套接字，将协议格式的命令请求发送给服务器。

Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器，并保持服务器自身的良好
运转。主要更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持
久化操作等等。
1、每100毫秒更新一次unixtime属性和mstime属性。

处理SIGTERM信号：
启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器，sigtermHandler函数，这个信号处理器负责在服务
器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。


第十五章	复制
旧版本的复制功能为同步和传播：
同步：
当客户端向从服务器发送SlAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作。
从服务器向主服务器发送SYNC命令完成。通过BGSAVE的RDB文件和缓冲区记录命令，完成同步。

命令传播：
在主从服务器同步之后，主服务器会将自己执行的写命令，发送给从服务器执行。

缺陷：
1、初次复制，可以很好完成任务。
2、断线后重新复制，效率低下。

因为生成RDB文件，需要耗费CPU，内存和IO。
发送给从服务器，浪费网络资源。
RDB文件的载入，耗费从服务器资源。


新版本复制功能：
新版本有PSYNC和SYNC两种模式：
PSYNC是部分重同步：当从服务器断开连接重连后，如果条件允许，主服务器可以将主从服务器连接断开期间执行
的写命令发送给从服务器，从服务器只要接受并且执行这些写命令，就可以更新至正确状态。

部分重同步：
1、主服务器复制偏移量，从服务器复制偏移量
2、主服务器复制积压缓冲区。
3、服务器的运行ID。

通过对比偏移量可以知道主从服务器是否处于一致状态。如果不一致就会从复制积压缓冲区得到。

复制积压缓冲区：一个固定长度的FIFO队列。
即如果从服务器偏移量的数据仍然存在在积压缓冲区中，主服务器对从服务器执行部分同步。
否则执行完整的同步。所以需要正确的估算和设置复制积压缓冲区大小。

复制ID：用于从服务器重新连接的时候，判断是否是之前连接的数据库服务器。

主从服务器：在命令传播阶段，从服务器默认以每秒一次的频率，向主服务器发送命令。
REPLCONF ACK：
其中replication_offset是从服务器当前的复制偏移量。
发送REPLCONF ACK命令对于主从服务器有三个作用：
1、检测主从服务器的网络连接状态。
2、辅助实现min-slaves选项。
3、检测命令丢失。

在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并且通过向主服务器发送命令请求来执行复制步骤，
而在复制操作的后期，主从服务器会互相成为对方的客户端。
主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器的一致，而从服务器则通过向主服务器，
发送命令来进行心跳检测，以及命令丢失检测。

第十六章	Sentinel
Sentinel(哨岗)是Redis高可用性的解决方案：由一个或者多个Sentinel实例组成的Sentinel系统可以监控任一多个
主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器
属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。
Sential状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，其中：
1、字典的键是被监视主服务器的名字。
2、字典的值是被监视主服务器对应的结构。

初始化Sential的最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向
主服务器发送命令，并且从命令回复中获取相关信息。
1、一个是命令连接，这个连接是专门用于向主服务器发送命令，并接受命令回复。















第十八章	发布和订阅
1、通过subscribe命令。客户端可以订阅一个或者多个频道，从而成为这些频道的订阅者：每当有其他客户端向被
订阅的频道发送消息时，频道的所有订阅者都会收到消息。
2、客户端可以通过psubscribe命令订阅一个或者多个模式，从而成为这些模式的订阅者。

unsubscribe命令的行为和subscribe命令的行为正好相反，当一个客户端退订某个或者某些频道的时候，服务器将从
pubsub_channels中解除客户端与被退订频道之间的关联。

频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是
一个链表，链表里面记录了所有订阅这个频道的客户端。

模式的订阅是一个链表，每个节点都是一个模式结构。

发送消息：
当Redis客户端执行PUBLISH <channel> <message>命令将消息message发送给频道channel的时候，服务端需要执行
以下两个动作：
1、将message发送给频道的订阅者。
2、如果有一个或者多个模式与频道匹配，发送给模式的订阅者。

查看订阅信息：
pubsub使客户端可以通过这个命令来查看频道或者模式的相关信息。


























