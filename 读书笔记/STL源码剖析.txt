STL六大组件：容器，算法，迭代器，仿函数，配接器，配置器。

SGI正是以malloc 和free 完成内存的配置和释放
考虑小区快造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用malloc和free函数，
第二级配置器则视情况采用不同的策略。当配置区块小于128Byte，采用memory pool整理。

第一级配置器：
1、allocate直接调用malloc，deallocate直接使用free。
2、模拟C++的set_new_handler处理内存不足的情况。

第二级配置器
1、维护16个自由链表。内存池通过malloc配置获得。
2、如果需求区块大于128bytes，就转而调用第一级配置器。
SGI第二级配置器会主动将小需求调制8的整倍数。所以维护16个free-lists

SGI STL中alloc默认是二级配置器。

typedef typename调用，是为了声明是变量还是类型。

initialzed_copy()特化 char,wchar 都可以通过memove内存底层操作。直接完成赋值。如果是POD类型，
就进行STL的copy算法。否则挨个进行赋值。
POD plain old  data 也就是标量型别的意思。pod型别拥有 trival cot/dtor/copy。因此我们可以对pod采用最
有效率的初值填写方法。
				 
其中uninitialized_fill_n()具有 commit 和 rollback语义，要么产生所有元素，否则一个都不产生，丢出异常。

第三章 迭代器
迭代器是一种行为类似指针的对象。指针中最重要的便是内容提领和成员访问，因此operator* 和operator->重载
工作。

参数型别推导，可以用template参数推导机制来取得。
函数返回值推导，利用内嵌型别进行推导，利用typedef typename可以设置返回值型别。
当迭代器是原生指针的时候，可以让上述的一般化概念针对特定情况做特殊处理，template partial specialization
即偏特化可以。即针对任何template参数更进一步的条件限制所设计出来的一个特化版本。

特性萃取器traits可以有效运作，每一个迭代器必须遵守约定，自行以内嵌型别定义的方式定义出相应型别。

value type：指迭代器所指对象的型别。任何一个打算与STL算法有完美搭配的class，都应该定义自己的valuetype。
difference type：定义两个迭代器之间的距离，也可以用来表示一个容器的最大容量。
reference type：返回一个引用。
pointer type：传回一个左值，令它代表p所指之物的地址。
iterator_category：迭代器的相应型别。

iterator_traits<InputIterator>::iterator_category()
产生一个临时对象，然后根据型别，决定调用哪一个重载函数。

traits编程技法大量运用于STL实现品中。他利用“内嵌型别”的编程技巧与编译器的template参数推导功能，增强C++
未能提供的关于型别认证方面的能力。

_type_traits 判断该型别是否为POD型别。




第四章 序列式容器
vector维护的是一个连续线性空间，所以不论其元素型别如何，普通指针都可以作为vector的迭代器而满足所有必要
条件。其数据结构就是线性连续空间。
容量：vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。
当我们push_back()将新元素插入于vector尾端时候，该函数首先检查是否还有备用空间，如果有就直接在备用空间
上构造元素，并且调整迭代器finish，使vector变大。如果没有，就进行重新配置，移动数据，释放原空间。
如何在指定空间进行construct：placement new
例如
template<typename t1,typename t2>
inline void construct(t1* p,const t2& value)
{
	new (p) T1(value);-
}


list相较于vector比价复杂，但是list每次插入或者删除都是配置或者释放一个元素空间。
operator++(int)后置++
operator++()前置++
list的数据结构是一个环状双向链表。在环状列表的尾端加上一个空白节点，符合STL规范的前闭后开区间。

deque
vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。
deque与vector差异在于deque允许在常数时间内对起头端进行元素的插入或者移除操作，二在deque没有所谓容量概
念。因为它是动态地分段连续空间组合。
deque任务便是这些分段的定量连续空间之上，维护其整体连续的假象。deque采用一小块连续空间map，其中每个元素
都是指针，指向另一段连续线性空间，称为缓冲区。缓冲区充当deque存储的主体。
deque是分段连续空间，维持其“整体连续”假象的任务，落在了迭代器operator++和operator--两个运算子身上。
deque中的迭代器包含cur，firt，last，node信息。
deque处理维护一个先前说过的指向map的指针外，也维护了start，finish两个迭代器，分别指向第一个缓冲区的第一
个元素和最后缓冲区的最后一个元素。

stack
stack是一种先进后出的数据结构，它只有一个出口，stack只允许新增元素，移除元素，取得最顶端元素。
stack以deque为底部结构，并封闭其头端口，便形成一个stack。
也可以用list作为双向开口的数据结构。

queue是一种先进先出的数据结构。
queue允许新增元素，移除元素，从最低端加入元素，取得顶端元素。
queue可以以deque为底部数据结构形成一个queue。queue实现简单，源代码简短。修改某物的接口，形成另一种容器
可以成为配接器。

heap
push_heap，	新加入元素放在最下层。
pop_heap,	获得heap中最大元素。
sort_heap，	一直进行pop_heap，获得有序序列。
make_heap，	转化为一个heap。


第五章 关联式容器
标准的STL关联式容器分为set和map两类。底层机制均为红黑树。

1、根据任一节点至NULL路径，黑色节点数目必须相同。所以新增节点必须为红。

状况1：叔叔节点是黑色，当前节点为外侧插入。对父节点和祖父节点做一次旋转。改变祖父和父节点的颜色。
状况2：叔叔节点是黑色，当前节点为内侧插入。对父节点和当前节点做一次单旋转，改变祖父和当前节点颜
	色，再将结果对G做一次单旋转，即可再次满足红黑树。
状况3：叔叔节点是红色，当前节点为外侧插入。对父节点和祖父节点做一次旋转，改变当前节点颜色，如果
	曾祖父为黑色，结束。
状况4：叔叔节点是红色，当前节点为外侧插入。对父节点和祖父节点做一次旋转，改变当前节点颜色，如果
	曾祖父为红色，继续向上做。

由下而上的程序机制。
为了避免父子节点都是红色，我们假设新增节点为A，就顺着A往上走，如果看到某节点的两个子节点都是红色，
就将该节点改为红色，将子节点改为黑色。

set特性：
所有元素都会根据元素的键值被自动排序。键值即实值。
不能通过迭代器修改元素的值。

map特性：
所有元素都会根据元素的键值被自动排序。所有元素是pair，同时拥有value和key。
可以通过迭代器修改map元素的实值，但是不能修改键值。


hashtable
除非采用开链策略，否则负载系数永远在0~1之间。
一次探测，二次探测，开链法。

第六章 算法
sort
关系型容器有自动排序功能，所以不需要sort。
vector，deque需要排序功能。
STL的sort算法，数据量大的时候使用快速排序算法，分段递归排序。一旦数据量小于某个门限，为了避免快排的递
归开销，会改用insertion sort，如果递归太多还会改用heap sort。
不当的选点，会导致不同的分割，致使快速排序恶化为O(N^2)，所以SGI STL改用introSort函数，有恶化二次行为的
倾向，能够自我侦测，转而改用HeapSort，使效率维持在HeapSort 上，但是又比直接使用HeapSort好。


introSort：
首先判断需要递归的层数。如果大于某个门限：一般是16，则改用heapsort。
否则利用三值中点法选择分割点。之后采用分段递归。

第七章 仿函数
仿函数：一种具有函数性质的对象。
函数指针无法和STL其他组件搭配。所以不用函数指针。
仿函数必须自定义operator()算子。
仿函数的功能主要用途是搭配STL算法。


第八章	配接器
配接器在STL组件的灵活组合运用功能上，扮演者轴承、转换器的角色。这也是一种设计模式。
例如queue和stack就是修饰deque的接口而成就出另一种容器的风貌。


