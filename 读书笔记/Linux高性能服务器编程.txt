高性能服务器程序框架
服务器解构为三个模块：
1、IO处理单元。
2、逻辑单元。
3、存储单元。


服务器模型：
1、C/S模型。
2、P2P模型。

Linux常用的IO复用函数是select，poll和epoll_wait，需要指出的是，IO复用函数本身是阻塞的，他们能提高程序效
率的原因在于他们具有同时监听多个IO事件的能力。

阻塞IO，IO复用都是同步IO模型。因为这三种IO模型，IO读写操作，都是在IO事件发生之后，有应用程序完成。
异步IO模型，用户直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知
应用程序的方式。异步的IO读写操作总是立即返回，而不论IO是否是阻塞，因为真正的读写操作已经由内核接管。
异步IO机制则由内核来执行IO操作。
同步IO模型要求用户代码自行执行IO操作，将数据从内核缓冲区读入用户缓冲区，或者用用户缓冲区写入内核缓冲区。
异步IO关注完成事件，同步IO关注就绪事件。
两种模型区分：内核向应用程序通知是何种IO时间，以及由谁来完成IO读写。



高效的事件处理模式：Reactor和Proactor
同步IO模型通常用于实现Reactor模式，异步IO模型则用于实现Proactor模式。

Reactor模式工作流程：
1、主线程往epoll内核事件注册socket读就绪事件。
2、主线程调用epoll_wait等待读。
3、当socket上有可读事件，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。
4、分配给工作线程，从socket读取数据，处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
5、主线程调用epoll_wait等待socket可写。
6、当socket上有可写事件时，epoll_wait通知主线程。主线程将socket可写事件放入队列。
7、唤醒工作线程，往socket上写入服务器处理客户请求的结果。

与Reactor模式不同的地方在于，Proactor模式将所有IO操作都交给主线程和内核来处理。工作线程仅仅负责业务
逻辑。使用异步IO模型，aio_read和aio_write为例，实现Proactor模式的工作流程是：
1、主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成
时如何通知应用程序。
2、主线程继续处理其他逻辑。
3、当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据可用。
4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用
aio_write函数向内核注册socket上的写完成事件，并且告诉内核用户写缓冲区的位置，以及写操作完成后如何通
知应用程序。
5、主线程继续处理其他逻辑。
6、当用户缓冲区的数据被写入socket之后，内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
7、应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理。

也就是说一般Proactor主线程中的epoll_wait调用仅能用来检测监听socket上的链接请求事件，而不能用来检测
链接socket上的读写事件。

两种高效的并发模式：半同步/半异步 ， 领导者/追随者模式
并发模式目的为了让程序同时执行多个任务，如果程序是计算密集型的，并发编程并没有优势，反而由于任务切换
是效率降低。但是如果程序时IO密集型，比如经常读写文件，访问数据库，就需要让被IO阻塞的线程主动放弃CPU，
将执行权转移到其他线程，这样CPU就可以充分利用。

异步执行效率高，实时性强，但是编写复杂，不利于调试。
同步效率和实时性较低，但是逻辑简单。

本网络库采用的是高效的半同步/半异步模式，当有新的连接到来时，主线程就接收并将新返回的链接socket派发给
某个工作线程。此后该新socket上的任何IO操作都有被选中的工作线程来处理，直到客户关闭连接。
因此每个线程都维持自己的事件循环，他们各自独立的监听不同事件。



领导者/追随者模式是多个线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。任一时间点，程序都
仅有一个领导者，他负责监听IO事件，而其他线程则都是追随者，他们休眠在线程池中等待成为新的领导者。当前的
领导者如果检测到IO事件，首先要从线程池中推选新的领导线程，然后处理IO事件，此后新领导等到IO，原来的领导
处理IO,二者并发。



提高服务器性能的其他建议
1、硬件资源：CPU的个数、速度，内存的大小。
2、软件资源：最大文件描述符数量，服务器程序本身，及如何从编程角度确保服务器性能。

池：
服务器硬件资源充足，提高服务器性能一个很直接的方法就是以空间换时间，即浪费服务器硬件资源，换取运行效
率。
常见的池有：内存池，进程池，线程池，连接池。


数据的复制：如果内核可以直接从socket或者文件读入，则应用程序就没有必要将这个数据从内核复制到应用程序。
可以直接使用零拷贝的sendfile来直接将其发送给客户端。
代码内部的数据复制也需要避免，当进程之间需要传递大量数据，我们就应该考虑使用共享内存来在他们之间直接
共享这些数据，而不是使用管道或者消息队列来传递。


上下文切换和锁
即使是IO密集型服务器，也不应该使用过多的工作线程，否则线程间的切换会占用大量的CPU时间。
锁会导致服务器效率低下，因为由他引入代码不仅不处理任何逻辑，而且访问内核资源。所以尽量避免使用锁。
尽量使用读写锁，只有当其中一个工作线程需要写这块内存时候，系统才需要去锁住这个区域。



文件描述符是服务器程序的宝贵资源。
1、修改文件描述符的限制。

2、调整内核参数。/proc/sys/fs，可以修改epoll内核事件表中注册的事件总量。
/proc/sys/net	可以修改backlog等tcp参数

3、GDB调试









